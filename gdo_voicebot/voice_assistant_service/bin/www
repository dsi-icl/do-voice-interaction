#!/usr/bin/env node

import http from "http";
import https from "https";
import fs from "fs";
import socketio from 'socket.io';

import app, {setupClient} from "../src/app";

app.use((err, req, res, _) => {
    console.error("Error", err);
    res.status(500).send("Internal server error");
});

startServer(http.createServer(app), normalizePort(process.env.PORT || "2000"));

// if (fs.existsSync("./ssl/server.key")) {
//     console.err("Loading security certificate");

//     const credentials = {
//         key: fs.readFileSync("./ssl/server.key", "utf8"),
//         cert: fs.readFileSync("./ssl/server.cert", "utf8"),
//         // ca: fs.readFileSync("./ssl/chain.pem", "utf8")
//     };

//     startServer(https.createServer(credentials, app), normalizePort(process.env.PORT || "443"));
// } else {
//     startServer(http.createServer(app), normalizePort(process.env.PORT || "2000"));
// }

function startServer(server, port) {
    server.listen(port);
    server.on("error", (error) => {
        if (error.syscall !== "listen") {
            console.error("Critical error", error);
            throw "Internal Server error";
        }

        let bind = typeof port === "string" ? "Pipe " + port : "Port " + port;

        switch (error.code) {
            case "EACCES":
                console.error(bind + " requires elevated privileges");
                process.exit(1);
                break;
            case "EADDRINUSE":
                console.error(bind + " is already in use");
                process.exit(1);
                break;
            default:
                console.error("Critical error", error);
                throw "Internal Server error";
        }
    });

    server.on("listening", () => {
        let addr = server.address();
        let bind = typeof addr === "string" ? "pipe " + addr : "port " + addr.port;
        console.log("Listening on " + bind);
    });

    socketio.listen(server).on("connect", setupClient);
}


function normalizePort(val) {
    let port = parseInt(val, 10);

    if (isNaN(port)) {
        // named pipe
        return val;
    }

    if (port >= 0) {
        // port number
        return port;
    }

    return false;
}
